//! Advanced Text Extraction Example
//!
//! This example demonstrates comprehensive text extraction capabilities:
//! - Extracting all text with formatting information
//! - Analyzing font usage
//! - Creating structured text output
//! - Performance considerations
//!
//! Run with: cargo run --example text_extraction <pdf_file>

use pdf_x::core::PDFDocument;
use std::collections::HashMap;
use std::env;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: cargo run --example text_extraction <pdf_file>");
        eprintln!("\nThis example demonstrates advanced text extraction capabilities.");
        return Ok(());
    }

    let pdf_path = &args[1];
    println!("ðŸ“„ Extracting text from: {}", pdf_path);

    // Read and parse PDF
    let pdf_data = std::fs::read(pdf_path)?;
    let mut doc = PDFDocument::open(pdf_data)?;

    let page_count = doc.page_count()?;
    println!("ðŸ“Š PDF has {} pages", page_count);

    // Extract text from all pages
    let mut all_text_items = Vec::new();
    let mut font_stats: HashMap<String, usize> = HashMap::new();

    for page_index in 0..page_count {
        println!("\nðŸ“– Processing page {}...", page_index + 1);

        let page = doc.get_page(page_index)?;
        let text_items = page.extract_text(&mut doc.xref_mut())?;

        // Collect font statistics
        for item in &text_items {
            if let Some(font_name) = &item.font_name {
                *font_stats.entry(font_name.clone()).or_insert(0) += 1;
            }
        }

        all_text_items.extend(text_items);
    }

    // Display extraction results
    println!("\nðŸ“‹ Text Extraction Results:");
    println!("  Total text items: {}", all_text_items.len());
    println!("  Total characters: {}", count_characters(&all_text_items));

    // Display font usage statistics
    if !font_stats.is_empty() {
        println!("\nðŸ”¤ Font Usage:");
        for (font_name, count) in font_stats.iter() {
            println!("  {}: {} occurrences", font_name, count);
        }
    }

    // Save structured output
    save_structured_text(&all_text_items, "extracted_text.txt")?;
    save_simple_text(&all_text_items, "simple_text.txt")?;

    println!("\nðŸ’¾ Output files:");
    println!("  extracted_text.txt - Structured text with metadata");
    println!("  simple_text.txt - Plain text content");

    Ok(())
}

fn count_characters(text_items: &[pdf_x::core::TextItem]) -> usize {
    text_items.iter().map(|item| item.text.len()).sum()
}

fn save_structured_text(text_items: &[pdf_x::core::TextItem], filename: &str) -> Result<(), std::io::Error> {
    use std::fs::File;
    use std::io::Write;

    let mut file = File::create(filename)?;

    writeln!(file, "# Structured Text Extraction Results")?;
    writeln!(file, "# Generated by PDF-X text extraction example")?;
    writeln!(file, "")?;

    for (i, item) in text_items.iter().enumerate() {
        writeln!(file, "Item {}:", i + 1)?;
        writeln!(file, "  Text: \"{}\"", item.text)?;

        if let Some(font_name) = &item.font_name {
            writeln!(file, "  Font: {}", font_name)?;
        }

        if let Some(font_size) = item.font_size {
            writeln!(file, "  Font size: {}", font_size)?;
        }

        if let Some((x, y)) = item.position {
            writeln!(file, "  Position: ({:.1}, {:.1})", x, y)?;
        }

        if let Some(mode) = item.rendering_mode {
            writeln!(file, "  Rendering mode: {}", mode)?;
        }

        writeln!(file, "")?;
    }

    Ok(())
}

fn save_simple_text(text_items: &[pdf_x::core::TextItem], filename: &str) -> Result<(), std::io::Error> {
    use std::fs::File;
    use std::io::Write;

    let mut file = File::create(filename)?;

    writeln!(file, "# Simple Text Extraction")?;
    writeln!(file, "# Plain text content from PDF")?;
    writeln!(file, "")?;

    let mut page_number = 1;
    let last_position = None;

    for item in text_items {
        // Check for position gaps to infer page breaks
        if let Some((x, y)) = item.position {
            if let Some((_, last_y)) = last_position {
                if last_y - y > 100.0 {
                    writeln!(file, "")?;
                    writeln!(file, "--- Page {} ---", page_number)?;
                    page_number += 1;
                }
            }
            last_position = Some((x, y));
        }

        writeln!(file, "{}", item.text)?;
    }

    Ok(())
}

/// Performance measurement example
#[allow(dead_code)]
fn measure_performance() -> Result<(), Box<dyn std::error::Error>> {
    use std::time::Instant;

    let pdf_path = "example.pdf";
    let pdf_data = std::fs::read(pdf_path)?;

    // Measure parsing time
    let start = Instant::now();
    let mut doc = PDFDocument::open(pdf_data)?;
    let parse_time = start.elapsed();

    // Measure text extraction time
    let start = Instant::now();
    let page = doc.get_page(0)?;
    let _text_items = page.extract_text(&mut doc.xref_mut())?;
    let extract_time = start.elapsed();

    println!("ðŸ“ˆ Performance Metrics:");
    println!("  Parse time: {:?}", parse_time);
    println!("  Text extraction time: {:?}", extract_time);
    println!("  PDF size: {} bytes", pdf_data.len());

    Ok(())
}