//! PDF text encoding support.
//!
//! This module provides encoding tables and functions for converting PDF
//! character codes to Unicode strings. PDFs can use various encodings for
//! simple fonts, and this module handles the conversion.
//!
//! Based on Adobe Technical Note #5176 and PDF specification.

/// Convert byte values to character codes for const array initialization.
const fn byte_to_char(b: u8) -> char {
    b as char
}

/// PDF text encoding type.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Encoding {
    /// Standard encoding (PDF StandardEncoding)
    Standard,
    /// WinAnsiEncoding (Windows ANSI / Code Page 1252)
    WinAnsi,
    /// MacRomanEncoding (Macintosh Roman)
    MacRoman,
    /// MacExpertEncoding
    MacExpert,
    /// PDFDocEncoding (same as StandardEncoding for our purposes)
    PDFDoc,
    /// Custom encoding (differences array)
    Custom(Vec<u16>), // Map char code to Unicode directly
    /// No explicit encoding
    None,
}

impl Encoding {
    /// Parse encoding from a PDF object.
    pub fn from_pdf_object(obj: &crate::core::parser::PDFObject) -> Option<Self> {
        match obj {
            crate::core::parser::PDFObject::Name(name) => match name.as_str() {
                "WinAnsiEncoding" => Some(Encoding::WinAnsi),
                "MacRomanEncoding" => Some(Encoding::MacRoman),
                "MacExpertEncoding" => Some(Encoding::MacExpert),
                "StandardEncoding" => Some(Encoding::Standard),
                "PDFDocEncoding" => Some(Encoding::PDFDoc),
                _ => None,
            },
            crate::core::parser::PDFObject::Dictionary(d) => {
                // Custom encoding with Differences array
                if let Some(diff) = d.get("Differences") {
                    if let crate::core::parser::PDFObject::Array(arr) = diff {
                        let mut map = vec![0u16; 256];
                        let mut current = 0u16;
                        for item in arr {
                            match &**item {
                                crate::core::parser::PDFObject::Number(n) => {
                                    current = *n as u16;
                                }
                                crate::core::parser::PDFObject::Name(name) => {
                                    if let Some(c) = name_to_unicode(name) {
                                        map[current as usize] = c;
                                    }
                                    current += 1;
                                }
                                _ => {}
                            }
                        }
                        return Some(Encoding::Custom(map));
                    }
                }
                None
            }
            _ => None,
        }
    }

    /// Convert a character code to Unicode using this encoding.
    pub fn char_to_unicode(&self, code: u8) -> char {
        let code = code as usize;
        match self {
            Encoding::Standard => STANDARD_ENCODING[code],
            Encoding::WinAnsi => WIN_ANSI_ENCODING[code],
            Encoding::MacRoman => MAC_ROMAN_ENCODING[code],
            Encoding::MacExpert => MAC_EXPERT_ENCODING[code],
            Encoding::PDFDoc => STANDARD_ENCODING[code],
            Encoding::Custom(map) => {
                if code < map.len() {
                    char::from_u32(map[code] as u32).unwrap_or('\u{FFFD}')
                } else {
                    '\u{FFFD}'
                }
            }
            Encoding::None => char::from_u32(code as u32).unwrap_or('\u{FFFD}'),
        }
    }
}

/// Convert a glyph name to Unicode character.
fn name_to_unicode(name: &str) -> Option<u16> {
    // This is a minimal implementation - a full version would include all PDF glyph names
    // For now, just handle common single-character names
    Some(match name {
        "A" => 'A' as u16,
        "B" => 'B' as u16,
        "C" => 'C' as u16,
        "D" => 'D' as u16,
        "E" => 'E' as u16,
        "F" => 'F' as u16,
        "G" => 'G' as u16,
        "H" => 'H' as u16,
        "I" => 'I' as u16,
        "J" => 'J' as u16,
        "K" => 'K' as u16,
        "L" => 'L' as u16,
        "M" => 'M' as u16,
        "N" => 'N' as u16,
        "O" => 'O' as u16,
        "P" => 'P' as u16,
        "Q" => 'Q' as u16,
        "R" => 'R' as u16,
        "S" => 'S' as u16,
        "T" => 'T' as u16,
        "U" => 'U' as u16,
        "V" => 'V' as u16,
        "W" => 'W' as u16,
        "X" => 'X' as u16,
        "Y" => 'Y' as u16,
        "Z" => 'Z' as u16,
        "a" => 'a' as u16,
        "b" => 'b' as u16,
        "c" => 'c' as u16,
        "d" => 'd' as u16,
        "e" => 'e' as u16,
        "f" => 'f' as u16,
        "g" => 'g' as u16,
        "h" => 'h' as u16,
        "i" => 'i' as u16,
        "j" => 'j' as u16,
        "k" => 'k' as u16,
        "l" => 'l' as u16,
        "m" => 'm' as u16,
        "n" => 'n' as u16,
        "o" => 'o' as u16,
        "p" => 'p' as u16,
        "q" => 'q' as u16,
        "r" => 'r' as u16,
        "s" => 's' as u16,
        "t" => 't' as u16,
        "u" => 'u' as u16,
        "v" => 'v' as u16,
        "w" => 'w' as u16,
        "x" => 'x' as u16,
        "y" => 'y' as u16,
        "z" => 'z' as u16,
        "space" => ' ' as u16,
        "quotedbl" => '"' as u16,
        "quoteright" => '\'' as u16,
        "quoterightbase" => '\'' as u16,
        "parenleft" => '(' as u16,
        "parenright" => ')' as u16,
        "comma" => ',' as u16,
        "hyphen" => '-' as u16,
        "period" => '.' as u16,
        "slash" => '/' as u16,
        "colon" => ':' as u16,
        "semicolon" => ';' as u16,
        "exclam" => '!' as u16,
        "question" => '?' as u16,
        _ => return None,
    })
}

/// Standard encoding as defined in Adobe Technical Note #5176.
///
/// Maps character codes 0-255 to Unicode characters.
const STANDARD_ENCODING: [char; 256] = encode_chars([
    // 0x00-0x1F: Control characters (unchanged)
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B,
    0x000C, 0x000D, 0x000E, 0x000F, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
    // 0x20-0x7F: ASCII printable characters (unchanged)
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B,
    0x002C, 0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, 0x0040, 0x0041, 0x0042, 0x0043,
    0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B,
    0x005C, 0x005D, 0x005E, 0x005F, 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, 0x0071, 0x0072, 0x0073,
    0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
    // 0x80-0x9F: Not assigned
    0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD,
    0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD,
    0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD,
    // 0xA0-0xFF: Special characters
    0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00AA, 0x00AB,
    0x00AC, 0x00AD, 0x00AE, 0x00AF, 0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
    0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, 0x00C0, 0x00C1, 0x00C2, 0x00C3,
    0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
    0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB,
    0x00DC, 0x00DD, 0x00DE, 0x00DF, 0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
    0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, 0x00F0, 0x00F1, 0x00F2, 0x00F3,
    0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
]);

/// WinAnsi encoding (Windows ANSI / Code Page 1252).
///
/// This is the most common encoding for PDFs created on Windows.
const WIN_ANSI_ENCODING: [char; 256] = encode_chars([
    // 0x00-0x1F: Control characters (unchanged)
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B,
    0x000C, 0x000D, 0x000E, 0x000F, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
    // 0x20-0x7E: ASCII printable characters (unchanged)
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B,
    0x002C, 0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, 0x0040, 0x0041, 0x0042, 0x0043,
    0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B,
    0x005C, 0x005D, 0x005E, 0x005F, 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, 0x0071, 0x0072, 0x0073,
    0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
    // 0x80-0x9F: Windows-specific characters
    0x20AC, 0xFFFD, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0160, 0x2039,
    0x0152, 0x017D, 0xFFFD, 0x0178, 0xFFFD, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0xFFFD,
    0x2122, 0xFFFD, 0xFB01, 0xFB02, 0xFFFD, 0xFFFD, 0xFFFD, 0xFFFD,
    // 0xA0-0xFF: Latin-1 supplement
    0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00AA, 0x00AB,
    0x00AC, 0x00AD, 0x00AE, 0x00AF, 0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
    0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, 0x00C0, 0x00C1, 0x00C2, 0x00C3,
    0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
    0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB,
    0x00DC, 0x00DD, 0x00DE, 0x00DF, 0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
    0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, 0x00F0, 0x00F1, 0x00F2, 0x00F3,
    0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
]);

/// MacRoman encoding (Macintosh Roman).
///
/// Used by PDFs created on classic Mac OS.
const MAC_ROMAN_ENCODING: [char; 256] = encode_chars([
    // 0x00-0x1F: Control characters (unchanged)
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B,
    0x000C, 0x000D, 0x000E, 0x000F, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
    // 0x20-0x7E: ASCII printable characters (unchanged)
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B,
    0x002C, 0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, 0x0040, 0x0041, 0x0042, 0x0043,
    0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B,
    0x005C, 0x005D, 0x005E, 0x005F, 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, 0x0071, 0x0072, 0x0073,
    0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
    // 0x80-0xFF: Macintosh-specific characters
    0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF,
    0x00EE, 0x00EC, 0x00C4, 0x00C5, 0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
    0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192, 0x00E1, 0x00ED, 0x00F3, 0x00FA,
    0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,
    0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,
    0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
    0x03B1, 0x03B2, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x03BC, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4,
    0x221E, 0x03C6, 0x03B5, 0x2229, 0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0,
]);

/// MacExpert encoding (simplified placeholder - not commonly used).
const MAC_EXPERT_ENCODING: [char; 256] = ['\u{FFFD}'; 256];

const fn encode_chars<const N: usize>(chars: [u32; N]) -> [char; N] {
    let mut arr = ['\u{FFFD}'; N];
    let mut i = 0;
    while i < N {
        arr[i] = unsafe { char::from_u32_unchecked(chars[i]) };
        i += 1;
    }
    arr
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_win_ansi_encoding() {
        // Basic ASCII
        assert_eq!(WIN_ANSI_ENCODING[65], 'A');
        assert_eq!(WIN_ANSI_ENCODING[97], 'a');

        // Euro sign at 0x80
        assert_eq!(WIN_ANSI_ENCODING[0x80], '\u{20AC}');

        // Copyright symbol at 0xA9
        assert_eq!(WIN_ANSI_ENCODING[0xA9], '\u{00A9}');
    }

    #[test]
    fn test_standard_encoding() {
        assert_eq!(STANDARD_ENCODING[65], 'A');
        assert_eq!(STANDARD_ENCODING[0xC4], 'Ã„');
    }
}
